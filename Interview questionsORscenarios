Expect real-world scenario-based questions across CI/CD, Cloud, Kubernetes, Terraform, and DevOps best practices:
1Ô∏è‚É£ Explain your CI/CD pipeline design. Which tools did you use and why?
2Ô∏è‚É£ Jenkins multi-environment deployment (dev/stage/prod) ‚Äì how would you do it?
3Ô∏è‚É£ Jenkins pipeline failures ‚Üí Debugging & real-time fix examples.
4Ô∏è‚É£ Dockerfile best practices ‚Üí Production-ready approach.
5Ô∏è‚É£ Kubernetes rolling updates using YAML ‚Üí Steps and concepts.
6Ô∏è‚É£ Terraform backend & remote state with locking ‚Üí Why & how.
7Ô∏è‚É£ Secrets management ‚Üí AWS Secrets Manager / Azure Key Vault.
8Ô∏è‚É£ Git branching strategies ‚Üí Gitflow in real projects.
9Ô∏è‚É£ Logging & Monitoring setup ‚Üí Tools and approach.
üîü DevSecOps ‚Üí Any real-time implementation you‚Äôve done.









1Ô∏è‚É£ CI/CD pipeline design ‚Äî tools & why

Flow: Code ‚Üí Build ‚Üí Test ‚Üí Scan ‚Üí Package ‚Üí Deploy ‚Üí Monitor.

Why these tools:

GitHub/GitLab: version control + PR workflow.

Jenkins/GitHub Actions: pipeline orchestration.

Docker: consistent builds.

Kubernetes + Helm: standardized deployments.

Trivy/SonarQube: security & quality gates.

Prometheus + Grafana: post-deployment monitoring.

Example Jenkinsfile (simplified):

pipeline {
  agent any
  stages {
    stage('Build') {
      steps {
        sh 'docker build -t myapp:${BUILD_NUMBER} .'
      }
    }
    stage('Test') {
      steps {
        sh 'pytest tests/'
      }
    }
    stage('Scan') {
      steps {
        sh 'trivy image myapp:${BUILD_NUMBER}'
      }
    }
    stage('Deploy') {
      steps {
        sh 'helm upgrade --install myapp ./charts/myapp --set image.tag=${BUILD_NUMBER}'
      }
    }
  }
}

2Ô∏è‚É£ Jenkins multi-env deployment

Use branches/tags to decide the environment.

Keep separate values-dev.yaml, values-stage.yaml, values-prod.yaml.

Add approval before prod.

Groovy snippet:

stage('Deploy') {
  when { branch 'main' }
  steps {
    input message: "Deploy to PROD?", ok: "Yes"
    sh 'helm upgrade --install myapp ./charts -f values-prod.yaml'
  }
}

3Ô∏è‚É£ Jenkins failures ‚Äî debug & fix

Example 1: Build fails due to dependency ‚Üí Clear cache, check lock file.

Example 2: Deployment stuck ‚Üí kubectl describe pod shows image pull error ‚Üí fix image tag or registry creds.

Example 3: Pipeline hangs ‚Üí Add timeout block in Jenkins.

options {
  timeout(time: 30, unit: 'MINUTES')
}

4Ô∏è‚É£ Dockerfile best practices

Use multi-stage builds to keep images small.

Run as non-root.

Add healthcheck.

Example:

FROM node:18 AS build
WORKDIR /app
COPY package*.json .
RUN npm install --production
COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=build /app/build /usr/share/nginx/html
USER 1001
HEALTHCHECK CMD curl -f http://localhost/ || exit 1

5Ô∏è‚É£ Kubernetes rolling update

Default deployment strategy = RollingUpdate.

Controlled using maxSurge and maxUnavailable.

Steps: update Deployment YAML ‚Üí kubectl apply ‚Üí monitor rollout ‚Üí rollback if needed.

YAML snippet:

strategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: 1
    maxUnavailable: 0

6Ô∏è‚É£ Terraform backend & state locking

Problem without backend: local state ‚Üí conflicts, overwrites.

Solution: remote state in S3/GCS/Azure Storage, lock with DynamoDB/Blob leases.

Prevents 2 engineers running terraform apply at the same time.

Backend example:

terraform {
  backend "s3" {
    bucket         = "tf-state-prod"
    key            = "network/terraform.tfstate"
    region         = "ap-south-1"
    dynamodb_table = "tf-locks"
    encrypt        = true
  }
}

7Ô∏è‚É£ Secrets management

AWS Secrets Manager: Store DB creds, API keys.

Access: IAM role ‚Üí app fetches via SDK/CLI.

Rotation: Automatic Lambda-based rotation.

K8s integration: External Secrets Operator.

Example Kubernetes ExternalSecret:

apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: db-secret
spec:
  secretStoreRef:
    name: aws-secrets
    kind: SecretStore
  target:
    name: db-credentials
  data:
    - secretKey: password
      remoteRef:
        key: prod/db/password

8Ô∏è‚É£ Git branching strategy

GitFlow (classic):

main = production

develop = staging

feature/* ‚Üí merged to develop

release/* ‚Üí tested ‚Üí merged to main

hotfix/* ‚Üí emergency fix on main

Modern approach: Many teams prefer Trunk-Based (small branches, feature flags).

9Ô∏è‚É£ Logging & Monitoring

Logs: Fluent Bit ‚Üí ELK/OpenSearch.

Metrics: Prometheus (scrape pods) + Grafana dashboards.

Tracing: OpenTelemetry + Jaeger.

Golden signals: latency, traffic, errors, saturation.

Prometheus scrape config:

scrape_configs:
- job_name: 'kubernetes-pods'
  kubernetes_sd_configs:
  - role: pod

üîü DevSecOps implementation

In CI/CD:

SAST ‚Üí SonarQube/CodeQL

Image scan ‚Üí Trivy

IaC scan ‚Üí Checkov/OPA

In CD: Admission controllers (Kyverno/Gatekeeper) enforce policies.

In runtime: Falco detects suspicious behavior.

Example: Pipeline fails if image has High/Critical CVEs.

stage('Security Scan') {
  steps {
    sh 'trivy image --exit-code 1 myapp:${BUILD_NUMBER}'
  }
}
